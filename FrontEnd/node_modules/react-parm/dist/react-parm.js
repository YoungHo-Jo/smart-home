(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom'], factory) :
  (factory((global.ReactParm = {}),global.React,global.ReactDOM));
}(this, (function (exports,React,reactDom) { 'use strict';

  React = React && React.hasOwnProperty('default') ? React['default'] : React;

  // external dependencies

  /**
   * @const {Array<string>} BOUND_METHODS the methods to be bound to the instance
   */
  var BOUND_METHODS = ['forceUpdate', 'setState'];

  /**
   * @constant {Object} IGNORED_COMPONENT_KEYS keys to ignore when creating a component
   */
  var IGNORED_COMPONENT_KEYS = {
    getInitialState: true,
    getInitialValues: true,
    isPure: true,
    onConstruct: true,
    state: true
  };

  /**
   * @constant {Object} IGNORED_STATIC_KEYS keys to ignore when assigning statics to a component
   */
  var IGNORED_STATIC_KEYS = {
    displayName: true
  };

  /**
   * @function addPropTypeIsRequired
   *
   * @description
   * add the isRequired method to the propType
   *
   * @param {function} propType the propType checker
   * @returns {function} the propType with the isRequired function added
   */
  var addPropTypeIsRequired = function addPropTypeIsRequired(propType) {
    return (propType.isRequired = function (props, key, component) {
      return props[key] == null // eslint-disable-line eqeqeq
      ? new Error('The prop `' + key + '` is marked as required in `' + component + '`, but its value is `' + props[key] + '`.') : propType(props, key, component);
    }) && propType;
  };

  /**
   * @function bindMethods
   *
   * @description
   * bind the methods to the component instance to ensure it can be used in a functional way
   *
   * @param {ReactComponent} instance the instance to bind the method to
   * @returns {void}
   */
  var bindMethods = function bindMethods(instance) {
    return BOUND_METHODS.map(function (method) {
      return Object.prototype.hasOwnProperty.call(instance[method], 'prototype') ? instance[method] = instance[method].bind(instance) : instance[method];
    });
  };

  /**
   * @function isClassComponent
   *
   * @description
   * is the value passed a valid react component class instance
   *
   * @param {any} value the value to test
   * @returns {boolean} is the value a react component instance
   */
  var isClassComponent = function isClassComponent(value) {
    return !!value && value instanceof React.Component;
  };

  /**
   * @function logInvalidInstanceError
   *
   * @description
   * notify the user that the instance passed is invalid
   *
   * @param {string} type the type of creator being called
   * @returns {void}
   */
  var logInvalidInstanceError = function logInvalidInstanceError(type) {
    return console.error('The instance provided for use with the ' + type + ' is not a valid React component instance.');
  }; // eslint-disable-line no-console

  /**
   * @function createRefCreator
   *
   * @description
   * create a method that will assign a ref value to the instance passed
   *
   * @param {function} getter the function that gets the component value for the ref
   * @returns {function(ReactComponent, string): function((HTMLElement|Component)): void} the ref create
   */
  var createRefCreator = function createRefCreator(getter) {
    return function (instance, ref) {
      return isClassComponent(instance) ? function (component) {
        return instance[ref] = getter(component);
      } : logInvalidInstanceError('ref');
    };
  };

  /**
   * @function getNamespacedRef
   *
   * @description
   * get the ref that is a combination of the raw component and the component's underlying HTML element
   *
   * @param {ReactComponent} component the component to assin
   * @returns {{component: ReactComponent, element: HTMLElement}} the namespaced ref
   */
  var getNamespacedRef = function getNamespacedRef(component) {
    return {
      component: component,
      element: reactDom.findDOMNode(component)
    };
  };

  /**
   * @function identity
   *
   * @description
   * return the first parameter passed
   *
   * @param {any} value the value to pass through
   * @returns {any} the first parameter passed
   */
  var identity = function identity(value) {
    return value;
  };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  /**
   * @function createCombinedRef
   *
   * @description
   * create a ref that assigns both the raw component and the underlying HTML element to the instance on a namespace
   *
   * @param {ReactComponent} instance the instance to assign to
   * @param {string} ref the instance value name
   * @returns {{component: ReactComponent, element: HTMLElement}} the combined ref
   */
  var createCombinedRef = createRefCreator(getNamespacedRef);

  /**
   * @function createComponentRef
   *
   * @description
   * create a ref that assigns the component itself to the instance
   *
   * @param {ReactComponent} instance the instance to assign to
   * @param {string} ref the instance value name
   * @returns {ReactComponent} the component ref
   */
  var createComponentRef = createRefCreator(identity);

  /**
   * @function createElementRef
   *
   * @description
   * create a ref that assigns the component's underlying HTML element to the instance
   *
   * @param {ReactComponent} instance the instance to assign to
   * @param {string} ref the instance value name
   * @returns {HTMLElement} the element ref
   */
  var createElementRef = createRefCreator(reactDom.findDOMNode);

  /**
   * @function createMethod
   *
   * @description
   * create a method that is a pure version of the lifecycle / instance method passed to it
   *
   * @param {ReactComponent} instance the instance the method is assigned to
   * @param {function} method the instance method
   * @param {Array<any>} extraArgs additional args to pass to the method
   * @returns {function(...Array<any>): any} the method with the instance passed as value
   */
  var createMethod = function createMethod(instance, method) {
    for (var _len = arguments.length, extraArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      extraArgs[_key - 2] = arguments[_key];
    }

    return isClassComponent(instance) ? bindMethods(instance) && function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return method.call(instance, instance, args, extraArgs);
    } : logInvalidInstanceError('method');
  };

  /**
   * @function createRender
   *
   * @description
   * create a method that is a pure version of the render method
   *
   * @param {ReactComponent} instance the instance the method is assigned to
   * @param {function} render the render method
   * @returns {function(): ReactElement} the method with the props and instance passed as values
   */
  var createRender = function createRender(instance, render) {
    return isClassComponent(instance) ? bindMethods(instance) && function () {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return render.call(instance, instance.props, instance, args);
    } : logInvalidInstanceError('render');
  };

  /**
   * @function createRenderProps
   *
   * @description
   * create a render props method, where the props passed and the instance it is rendered in are passed as props to it
   *
   * @param {ReactComponent} instance the instance the method is assigned to
   * @param {function} renderProps the render props method
   * @returns {function(Object): ReactElement} the method with the props and instance passed as values
   */
  var createRenderProps = function createRenderProps(instance, renderProps) {
    return isClassComponent(instance) ? bindMethods(instance) && function (props) {
      for (var _len4 = arguments.length, restOfArgs = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        restOfArgs[_key4 - 1] = arguments[_key4];
      }

      return renderProps.call(instance, props, instance, restOfArgs);
    } : logInvalidInstanceError('render props');
  };

  /**
   * @function createValue
   *
   * @description
   * create a value to assign to the instance based on props or the instance itself
   *
   * @param {ReactComponent} instance the instance the method is assigned to
   * @param {function} getValue the function to get the value with
   * @param {Array<any>} extraArgs additional args to pass to the method
   * @returns {function(...Array<any>): any} the method with the instance passed as value
   */
  var createValue = function createValue(instance, getValue) {
    for (var _len5 = arguments.length, extraArgs = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
      extraArgs[_key5 - 2] = arguments[_key5];
    }

    return isClassComponent(instance) ? bindMethods(instance) && getValue.call(instance, instance, extraArgs) : logInvalidInstanceError('value');
  };

  /**
   * @function createComponent
   *
   * @description
   * create a component from the render method and any options passed
   *
   * @param {function|Object} render the function to render the component, or the options for future curried calls
   * @param {Object} [passedOptions] the options to render the component with
   * @param {function} [getInitialState] the method to get the initial state with
   * @param {boolean} [isPure] is PureComponent used
   * @param {function} [onConstruct] a method to call when constructing the component
   * @param {Object} [state] the initial state
   * @returns {function|ReactComponent} the component class, or a curried call to itself
   */
  var createComponent = function createComponent(render, passedOptions) {
    if (typeof render !== 'function') {
      var _options = render || {};

      return function (render, moreOptions) {
        return typeof render === 'function' ? createComponent(render, _extends({}, _options, moreOptions || {})) : createComponent(_extends({}, _options, render || {}));
      };
    }

    var options = passedOptions || {};
    var getInitialState = options.getInitialState,
        getInitialValues = options.getInitialValues,
        isPure = options.isPure,
        onConstruct = options.onConstruct,
        state = options.state;


    var Constructor = isPure ? React.PureComponent : React.Component;

    function ParmComponent(initialProps) {
      Constructor.call(this, initialProps);

      this.state = typeof getInitialState === 'function' ? createValue(this, getInitialState) : state || null;

      for (var key in options) {
        if (!IGNORED_COMPONENT_KEYS[key]) {
          this[key] = typeof options[key] === 'function' ? options[key].isRender ? createRender(this, options[key]) : options[key].isRenderProps ? createRenderProps(this, options[key]) : createMethod(this, options[key]) : options[key];
        }
      }

      var values = typeof getInitialValues === 'function' ? createValue(this, getInitialValues) : null;

      if (values && (typeof values === 'undefined' ? 'undefined' : _typeof(values)) === 'object') {
        for (var _key6 in values) {
          this[_key6] = values[_key6];
        }
      }

      this.render = createRender(this, render);

      if (typeof onConstruct === 'function') {
        onConstruct(this);
      }

      return this;
    }

    ParmComponent.prototype = Object.create(Constructor.prototype);

    ParmComponent.displayName = render.displayName || render.name || 'ParmComponent';

    Object.keys(render).forEach(function (staticKey) {
      return !IGNORED_STATIC_KEYS[staticKey] && (ParmComponent[staticKey] = render[staticKey]);
    });

    return ParmComponent;
  };

  /**
   * @function createPropType
   *
   * @description
   * create a custom prop type handler
   *
   * @param {function(Object): (Error|null)} handler the prop type handler
   * @returns {function} the custom prop type
   */
  var createPropType = function createPropType(handler) {
    return addPropTypeIsRequired(function (props, key, component, locationIgnored, fullKey) {
      return handler({
        component: component,
        key: key,
        name: fullKey ? fullKey.split(/(\.|\[)/)[0] : key,
        path: fullKey || key,
        props: props,
        value: props[key]
      });
    });
  };

  exports.createCombinedRef = createCombinedRef;
  exports.createComponentRef = createComponentRef;
  exports.createElementRef = createElementRef;
  exports.createMethod = createMethod;
  exports.createRender = createRender;
  exports.createRenderProps = createRenderProps;
  exports.createValue = createValue;
  exports.createComponent = createComponent;
  exports.createPropType = createPropType;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-parm.js.map
