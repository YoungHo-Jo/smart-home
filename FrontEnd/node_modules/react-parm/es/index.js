var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

// external dependencies
import React from 'react';
import { findDOMNode } from 'react-dom';

// utils
import { IGNORED_COMPONENT_KEYS, IGNORED_STATIC_KEYS, addPropTypeIsRequired, bindMethods, createRefCreator, getNamespacedRef, identity, isClassComponent, logInvalidInstanceError } from './utils';

/**
 * @function createCombinedRef
 *
 * @description
 * create a ref that assigns both the raw component and the underlying HTML element to the instance on a namespace
 *
 * @param {ReactComponent} instance the instance to assign to
 * @param {string} ref the instance value name
 * @returns {{component: ReactComponent, element: HTMLElement}} the combined ref
 */
export var createCombinedRef = createRefCreator(getNamespacedRef);

/**
 * @function createComponentRef
 *
 * @description
 * create a ref that assigns the component itself to the instance
 *
 * @param {ReactComponent} instance the instance to assign to
 * @param {string} ref the instance value name
 * @returns {ReactComponent} the component ref
 */
export var createComponentRef = createRefCreator(identity);

/**
 * @function createElementRef
 *
 * @description
 * create a ref that assigns the component's underlying HTML element to the instance
 *
 * @param {ReactComponent} instance the instance to assign to
 * @param {string} ref the instance value name
 * @returns {HTMLElement} the element ref
 */
export var createElementRef = createRefCreator(findDOMNode);

/**
 * @function createMethod
 *
 * @description
 * create a method that is a pure version of the lifecycle / instance method passed to it
 *
 * @param {ReactComponent} instance the instance the method is assigned to
 * @param {function} method the instance method
 * @param {Array<any>} extraArgs additional args to pass to the method
 * @returns {function(...Array<any>): any} the method with the instance passed as value
 */
export var createMethod = function createMethod(instance, method) {
  for (var _len = arguments.length, extraArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    extraArgs[_key - 2] = arguments[_key];
  }

  return isClassComponent(instance) ? bindMethods(instance) && function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return method.call(instance, instance, args, extraArgs);
  } : logInvalidInstanceError('method');
};

/**
 * @function createRender
 *
 * @description
 * create a method that is a pure version of the render method
 *
 * @param {ReactComponent} instance the instance the method is assigned to
 * @param {function} render the render method
 * @returns {function(): ReactElement} the method with the props and instance passed as values
 */
export var createRender = function createRender(instance, render) {
  return isClassComponent(instance) ? bindMethods(instance) && function () {
    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return render.call(instance, instance.props, instance, args);
  } : logInvalidInstanceError('render');
};

/**
 * @function createRenderProps
 *
 * @description
 * create a render props method, where the props passed and the instance it is rendered in are passed as props to it
 *
 * @param {ReactComponent} instance the instance the method is assigned to
 * @param {function} renderProps the render props method
 * @returns {function(Object): ReactElement} the method with the props and instance passed as values
 */
export var createRenderProps = function createRenderProps(instance, renderProps) {
  return isClassComponent(instance) ? bindMethods(instance) && function (props) {
    for (var _len4 = arguments.length, restOfArgs = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      restOfArgs[_key4 - 1] = arguments[_key4];
    }

    return renderProps.call(instance, props, instance, restOfArgs);
  } : logInvalidInstanceError('render props');
};

/**
 * @function createValue
 *
 * @description
 * create a value to assign to the instance based on props or the instance itself
 *
 * @param {ReactComponent} instance the instance the method is assigned to
 * @param {function} getValue the function to get the value with
 * @param {Array<any>} extraArgs additional args to pass to the method
 * @returns {function(...Array<any>): any} the method with the instance passed as value
 */
export var createValue = function createValue(instance, getValue) {
  for (var _len5 = arguments.length, extraArgs = Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
    extraArgs[_key5 - 2] = arguments[_key5];
  }

  return isClassComponent(instance) ? bindMethods(instance) && getValue.call(instance, instance, extraArgs) : logInvalidInstanceError('value');
};

/**
 * @function createComponent
 *
 * @description
 * create a component from the render method and any options passed
 *
 * @param {function|Object} render the function to render the component, or the options for future curried calls
 * @param {Object} [passedOptions] the options to render the component with
 * @param {function} [getInitialState] the method to get the initial state with
 * @param {boolean} [isPure] is PureComponent used
 * @param {function} [onConstruct] a method to call when constructing the component
 * @param {Object} [state] the initial state
 * @returns {function|ReactComponent} the component class, or a curried call to itself
 */
export var createComponent = function createComponent(render, passedOptions) {
  if (typeof render !== 'function') {
    var _options = render || {};

    return function (render, moreOptions) {
      return typeof render === 'function' ? createComponent(render, _extends({}, _options, moreOptions || {})) : createComponent(_extends({}, _options, render || {}));
    };
  }

  var options = passedOptions || {};
  var getInitialState = options.getInitialState,
      getInitialValues = options.getInitialValues,
      isPure = options.isPure,
      onConstruct = options.onConstruct,
      state = options.state;


  var Constructor = isPure ? React.PureComponent : React.Component;

  function ParmComponent(initialProps) {
    Constructor.call(this, initialProps);

    this.state = typeof getInitialState === 'function' ? createValue(this, getInitialState) : state || null;

    for (var key in options) {
      if (!IGNORED_COMPONENT_KEYS[key]) {
        this[key] = typeof options[key] === 'function' ? options[key].isRender ? createRender(this, options[key]) : options[key].isRenderProps ? createRenderProps(this, options[key]) : createMethod(this, options[key]) : options[key];
      }
    }

    var values = typeof getInitialValues === 'function' ? createValue(this, getInitialValues) : null;

    if (values && (typeof values === 'undefined' ? 'undefined' : _typeof(values)) === 'object') {
      for (var _key6 in values) {
        this[_key6] = values[_key6];
      }
    }

    this.render = createRender(this, render);

    if (typeof onConstruct === 'function') {
      onConstruct(this);
    }

    return this;
  }

  ParmComponent.prototype = Object.create(Constructor.prototype);

  ParmComponent.displayName = render.displayName || render.name || 'ParmComponent';

  Object.keys(render).forEach(function (staticKey) {
    return !IGNORED_STATIC_KEYS[staticKey] && (ParmComponent[staticKey] = render[staticKey]);
  });

  return ParmComponent;
};

/**
 * @function createPropType
 *
 * @description
 * create a custom prop type handler
 *
 * @param {function(Object): (Error|null)} handler the prop type handler
 * @returns {function} the custom prop type
 */
export var createPropType = function createPropType(handler) {
  return addPropTypeIsRequired(function (props, key, component, locationIgnored, fullKey) {
    return handler({
      component: component,
      key: key,
      name: fullKey ? fullKey.split(/(\.|\[)/)[0] : key,
      path: fullKey || key,
      props: props,
      value: props[key]
    });
  });
};